TYPEMAP

nsIDOMAbstractView *		T_MOZDOM_GENERIC_WRAPPER
nsIDOMDocumentView *		T_MOZDOM_GENERIC_WRAPPER
nsIDOMEvent *			T_MOZDOM_GENERIC_WRAPPER
nsIDOMUIEvent *			T_MOZDOM_GENERIC_WRAPPER
nsIDOMDocumentEvent *		T_MOZDOM_GENERIC_WRAPPER
nsIDOMMutationEvent *		T_MOZDOM_GENERIC_WRAPPER
nsIDOMKeyEvent *		T_MOZDOM_GENERIC_WRAPPER
nsIDOMMouseEvent *		T_MOZDOM_GENERIC_WRAPPER
nsIDOMEventTarget *		T_MOZDOM_GENERIC_WRAPPER
nsIDOMEventListener *		T_MOZDOM_GENERIC_WRAPPER
nsIDOMWindow *			T_MOZDOM_GENERIC_WRAPPER
nsIDOMWindowCollection *	T_MOZDOM_GENERIC_WRAPPER
nsIDOMDocument *		T_MOZDOM_GENERIC_WRAPPER
nsIDOMDocumentFragment *	T_MOZDOM_GENERIC_WRAPPER
nsIDOMDocumentType *		T_MOZDOM_GENERIC_WRAPPER
nsIDOMNode *			T_MOZDOM_GENERIC_WRAPPER
nsIDOMNodeList *		T_MOZDOM_GENERIC_WRAPPER
nsIDOMNamedNodeMap *		T_MOZDOM_GENERIC_WRAPPER
nsIDOMElement *			T_MOZDOM_GENERIC_WRAPPER
nsIDOMEntityReference *		T_MOZDOM_GENERIC_WRAPPER
nsIDOMAttr *			T_MOZDOM_GENERIC_WRAPPER
nsIDOMProcessingInstruction *	T_MOZDOM_GENERIC_WRAPPER
nsIDOMCDATASection *		T_MOZDOM_GENERIC_WRAPPER
nsIDOMComment *			T_MOZDOM_GENERIC_WRAPPER
nsIDOMCharacterData *		T_MOZDOM_GENERIC_WRAPPER
nsIDOMText *			T_MOZDOM_GENERIC_WRAPPER
nsIDOMDOMImplementation *	T_MOZDOM_GENERIC_WRAPPER
nsIDOMRange *			T_MOZDOM_GENERIC_WRAPPER

nsIWebBrowser *			T_MOZDOM_GENERIC_WRAPPER
nsISelection *			T_MOZDOM_GENERIC_WRAPPER
nsISupports *			T_MOZDOM_GENERIC_WRAPPER

PRUint32	T_UV
PRUint16	T_UV
PRInt32	T_IV
PRInt16	T_UV
PRBool	T_BOOL
DOMTimeStamp	T_UV

# Use this for methods with "const nsAString &" arguments;
# e.g. for InitEvent(const nsAString &evtType, ...)
# do something like
# void
# moz_dom_init_event (event, type, ...)
# 	nsIDOMEvent *event;
# 	nsEmbedString type;
# 	...
#     CODE:
# 	event->InitEvent(type, ...)
nsEmbedString	T_NSASTRING

nsIID	T_NSIID


INPUT

# (T_GPERL_GENERIC_WRAPPER from Glib/typemap; I wasn't sure if having the
# same name would conflict or something)
# a general-purpose typemap... strips any trailing star and/or leading "const",
# leaving only the type name in the form SvMyType.  this allows you to make a
# typedef such as "typedef MyType MyType_ornull", and SvMyType_ornull will be
# called for those.
T_MOZDOM_GENERIC_WRAPPER
	$var = Sv${(my $ntype = $type) =~ s/(?:const\s+)?([:\w]+)(?:\s*\*)$/$1/x;
		   \$ntype} ($arg);


# For an `nsEmbedString' arg, this converts the incoming SV* arg
# to a UTF-16 nsEmbedString, suitable for "const nsAString &"
# input parameters.

T_NSASTRING
	char * str$var = (char *) SvPV_nolen($arg);
	nsEmbedCString u8$var(str$var);
	NS_CStringToUTF16(u8$var, NS_CSTRING_ENCODING_UTF8, $var);

T_NSIID
	char * str$var = (char *) SvPV_nolen($arg);
	$var.Parse(str$var);


OUTPUT

T_MOZDOM_GENERIC_WRAPPER
	$arg = newSV${(my $ntype = $type) =~ s/(?:const\s+)?([:\w]+)(?:\s*\*)$/$1/;
		      \$ntype} ($var);


# For a `nsEmbedString' return value, takes care of converting
# a UTF-16 nsEmbedString to a UTF-8 SV * (const char *).
# Generally this is necessary for methods with "nsAString &"
# arguments that are passed in by reference; for example,
# GetType(nsAString &type):
#
# nsEmbedString
# moz_dom_get_type (event)
# 	nsIDOMEvent *event;
#     PREINIT:
# 	nsEmbedString type;
#     CODE:
#	event->GetType(type);
# 	RETVAL = type;
#     OUTPUT:
# 	RETVAL

T_NSASTRING
	nsEmbedCString u8$var;
	const char * u8str$var;
	NS_UTF16ToCString($var, NS_CSTRING_ENCODING_UTF8, u8$var);
	u8str$var = u8$var.get();
	sv_setpv((SV*)$arg, u8str$var);

# XXX: I think ToString leaks since I don't free the string
T_NSIID
	sv_setpv((SV*)$arg, $var.ToString());
